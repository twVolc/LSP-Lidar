import tkinter as tk
import tkinter.ttk as ttk
from tkinter import filedialog
from tkinter import messagebox
import tkinter.font as tkFont

import matplotlib
import matplotlib.pyplot as plt
from matplotlib.backends.backend_tkagg import FigureCanvasTkAgg, NavigationToolbar2TkAgg

from threading import Thread
import queue
import sys

import numpy as np

from post_process import process_data, ProcessInfo, remove_empty_scans, save_hdf5
from LSP_control import ProcessLSP
from data_handler import handle_data

matplotlib.use('TkAgg')


class MainGUI(ttk.Frame):
    """Main GUI to help in acquisition and running of LSP/lidar instrument"""
    def __init__(self, parent):
        """Initialise class"""
        ttk.Frame.__init__(self, parent)

        self.parent = parent
        self.parent.title('LSP-Lidar Control')
        self.parent.protocol('WM_DELETE_WINDOW', self.exit_app)

        self.initdir = 'C:\\Users\\tw9616\\Documents\\PhD\\EE Placement\\Lidar\\RPLIDAR_A2M6\\VC2017 Test\\sdk\\output\\win32\\Release\\'

        self.setts = SettingsGUI()      # Holds GUI settings
        self.info = ProcessInfo()       # Holds information needed for processing
        self.lsp_proc = ProcessLSP()    # Has some useful processing algorithms for LSP data
        self._q = queue.Queue()         # Queue to retrieve data from thread

        # ----------------------------------------------------------------
        # Tab setup
        self.tabs = ttk.Notebook(self.parent)
        self.acqFrame = ttk.Frame(self.tabs)
        self.analysisFrame = ttk.Frame(self.tabs)
        self.tabs.add(self.acqFrame, text='Acquisition')
        self.tabs.add(self.analysisFrame, text='Analysis')
        self.tabs.pack(fill="both", expand=1)

        # Setup frames
        self.__acq_setup__(self.acqFrame)
        self.__analysis_setup__(self.analysisFrame)
        # -----------------------------------------------------------------

    def exit_app(self):
        """Exit app options"""
        if messagebox.askokcancel("Quit", "Are you sure you want to quit?"):
            # Killing all threads and then exiting the GUI
            self.parent.destroy()
            sys.exit()

    def __acq_setup__(self, frame):
        """Setup acquisition frame"""
        self.acquiring = False      # Used to determine whether we are currently in a state of acquisition or not

        self.acq_butt = ttk.Button(frame, text='Start Acquisition', command=self.handle_acquisition)
        self.acq_butt.pack(side=tk.LEFT, fill=tk.BOTH, expand=False)

        self.messages = MessagesGUI(frame)
        self.messages.frame.pack(side=tk.RIGHT, fill=tk.BOTH)

    def __analysis_setup__(self, frame):
        """Setup analysis frame"""

        # Setup file choice and associated button
        file_frame = tk.Frame(frame)
        file_frame.grid(row=0, column=0, padx=2, pady=2, sticky='nsw')

        self.file_loader = FileSelector(file_frame, type=FileSelector.LOAD, title='Process file:')
        self.file_loader.filetypes = [('MAT file', '*.mat'), ('All files', '*.*')]
        self.file_loader.frame.pack()

        # Process button
        process_butt = tk.Button(file_frame, text='RUN', bg='limegreen',
                                 font=self.setts.mainFontBold, command=self.process_data_thread)
        # process_butt.grid(row=1, column=2, pady=2)
        process_butt.pack()

        self.file_saver = FileSelector(file_frame, type=FileSelector.SAVE, title='Save file:')
        self.file_saver.filetypes = [('HDF5', '*.h5'), ('All files', '*.*')]
        self.file_saver.frame.pack()

        save_butt = tk.Button(file_frame, text='SAVE', command=self.save_data,
                              bg='orange', font=self.setts.mainFontBold)
        save_butt.pack()

        # --------------------------------------------------------------------
        # Settings setup
        # --------------------------------------------------------------------
        set_frame = tk.LabelFrame(frame, text='Settings', relief=tk.GROOVE, borderwidth=2)
        set_frame.grid(row=0, column=1, sticky='w', padx=2, pady=2)

        self.dir_var = tk.StringVar()
        self.dir_var.set(self.setts.lsp_first[0])
        dir_lab = ttk.Label(set_frame, text='Instrument Orientation:')
        dir_lab.grid(row=0, column=0)
        dir_ent = ttk.OptionMenu(set_frame, self.dir_var, self.setts.lsp_first[0],
                                 self.setts.lsp_first[0], self.setts.lid_first[0])
        dir_ent.grid(row=0, column=1)

        # --------------------------------------------------------------------
        # Plot setup
        # --------------------------------------------------------------------
        plot_frame = tk.Frame(frame)
        plot_frame.grid(row=2, column=0, columnspan=4)
        # Lidar distance plot
        self.lid_plt = PlottingGUI(plot_frame, 'Distance [mm]')
        self.lid_plt.frame.pack(side=tk.LEFT)

        # Lidar distance plot (interpolated)
        self.lid_interp_plt = PlottingGUI(plot_frame, 'Distance [mm]')
        self.lid_interp_plt.frame.pack(side=tk.LEFT)

        # LSP temperature plot
        self.temp_plt = PlottingGUI(plot_frame, r'Temperature [$^o$C]')
        self.temp_plt.frame.pack(side=tk.LEFT)
        # --------------------------------------------------------------------

    def handle_acquisition(self):
        """Starts LSP/lidar acquisition sequence"""
        if not self.acquiring:
            self.data_q = queue.Queue()
            self.acquiring = True

            self.data_thread = Thread(target=handle_data, args=(self.data_q, ))
            self.data_thread.daemon = True
            self.data_thread.start()

            self.acq_butt.configure(text="Stop Acquisition")

        else:
            self.acquiring = False
            self.data_q.put(-1)     # Tell data_handler() to close down

            self.acq_butt.configure(text="Start Acquisition")

    def process_data_thread(self):
        """Start thread for processing data"""
        self.data_dict = self.__prep_data__()
        if self.data_dict is None:
            return

        instr_dir = self.dir_var.get()
        if instr_dir == self.setts.lid_first[0]:
            self.info.INSTRUMENT_DIRECTION = self.setts.lid_first[1]
        elif instr_dir == self.setts.lsp_first[0]:
            self.info.INSTRUMENT_DIRECTION = self.setts.lsp_first[1]
        else:
            print('Error!!! Unknown instrument direction definition: %s' % instr_dir)
            return

        # Perform main processing
        # t = Thread(target=process_data, args=(self.data_dict['lidar'], self.data_dict['array'],
        #                                       self.data_dict['speed'], self._q,))
        # t.Daemon = True
        # t.start()
        self.data_array, self.raw_lid = process_data(self.data_dict['lidar'], self.data_dict['array'],
                                                     self.data_dict['speed'], info=self.info)
        self.update_plots()

    def __prep_data__(self):
        """Initialising things for processing of data"""
        array_main = np.zeros([self.info.NUM_SCANS, self.info.len_lsp, self.info.NUM_Z_DIM])
        if self.file_loader.filename is None:
            print('Error!!! No file selected, cannot process data.')
            return None
        dat = self.lsp_proc.read_array(self.file_loader.filename)['arr']
        full_dat = remove_empty_scans(dat)

        # Extract data then pack into dictionary to be returned
        scan_speeds = full_dat[:, self.info.speed_idx]
        array_main[:, :, self.info.TEMP_IDX] = full_dat[:, 0:self.info.len_lsp]
        lidar = full_dat[:, self.info.lid_idx_start:]
        scan_num = np.arange(0, full_dat.shape[0])

        # Compile data into dictionary
        data_dict = {'array': array_main, 'speed': scan_speeds, 'lidar': lidar, 'Num_scans': scan_num}
        return data_dict

    def update_plots(self):
        """Updates plots with new data"""
        self.lid_plt.update_cmap(self.raw_lid)
        self.lid_interp_plt.update_cmap(self.data_array[:, :, self.info.DIST_IDX])
        self.temp_plt.update_cmap(self.data_array[:, :, self.info.TEMP_IDX])

    def save_data(self):
        """Instigate saving of data"""
        save_hdf5(self.data_array, self.file_saver.filename)

        pass


class SettingsGUI:
    """Class to hold some settings of the GUI"""
    def __init__(self):
        self.version = '1.0'

        self.bgColour = "#ccd"
        self.style = ttk.Style()
        self.style.configure("TFrame", background=self.bgColour)

        self.font_size = 12
        self.mainFont = tkFont.Font(family='Helvetica', size=self.font_size)
        self.mainFontBold = tkFont.Font(family='Helvetica', size=self.font_size, weight='bold')

        # Relating to instrument orientation
        self.lid_first = ['Lidar First', -1]       # List holding string for GUI and associated value for ProcessInfo
        self.lsp_first = ['LSP First', 1]          # Ditto


class MessagesGUI:
    """Class to control messages in the GUI"""
    def __init__(self, frame):
        self.num_messages = 50
        self.setts = SettingsGUI()

        self.mess_sep = '\n'
        self.mess_start = '>> '

        # Frame setup
        self.frame = ttk.Frame(frame, relief=tk.GROOVE, borderwidth=2)
        self.messTitle = tk.Label(self.frame, text='Messages:', font=self.setts.mainFont,
                                  anchor="w").pack(side="top", fill='both')

        self.canvas = tk.Canvas(self.frame, borderwidth=0, background=self.setts.bgColour)
        self.canv_frame = tk.Frame(self.canvas, background=self.setts.bgColour)
        self.vsb = tk.Scrollbar(self.frame, orient="vertical", command=self.canvas.yview)
        self.canvas.configure(yscrollcommand=self.vsb.set)
        self.vsb_x = tk.Scrollbar(self.frame, orient="horizontal", command=self.canvas.xview)
        self.canvas.configure(xscrollcommand=self.vsb_x.set)

        self.vsb.pack(side="right", fill="y")
        self.vsb_x.pack(side="bottom", fill="x")
        self.canvas.pack(side="left", fill="both", expand=True)
        self.canvas.create_window((1, 5), window=self.canv_frame, anchor="nw", tags=self.frame)

        self.canv_frame.bind("<Configure>", self._onFrameConfigure)

        self.init_message()

    def _onFrameConfigure(self, event):
        """Not sure what this does, but it does something important..."""
        self.canvas.configure(scrollregion=self.canvas.bbox('all'))

    def init_message(self):
        """Setup message box with initial messages"""
        row_mess = 0
        tk.Label(self.canv_frame, text='Welcome to 3DTherm', background=self.setts.bgColour,
                 font=self.setts.mainFontBold).grid(row=row_mess, column=0, sticky='w')
        row_mess += 1
        tk.Label(self.canv_frame, text='3DTherm v' + self.setts.version,
                 background=self.setts.bgColour, font=self.setts.mainFont).grid(row=row_mess, column=0, sticky='w')
        row_mess += 1

        self.message_holder = self.mess_start + self.mess_sep
        for i in range(self.num_messages):
            self.message_holder += self.mess_start + self.mess_sep

        self.label = tk.Label(self.canv_frame, text=self.message_holder, background=self.setts.bgColour,
                              font=self.setts.mainFontBold, justify=tk.LEFT)
        self.label.grid(row=row_mess, column=0, sticky='w')

    def message(self, mess_new):
        """Update message list"""
        mess_new = self.mess_start + mess_new + self.mess_sep
        self.message_holder = mess_new + self.message_holder.rsplit(self.mess_start, 1)[
            0]  # Remove first line and append new one
        self.label.configure(text=self.message_holder)


class FileSelector:
    """Class to build frame for selecting a file path
    -> Label for title, label for pathname, button for file selection"""
    # Enumerators for type (save/load)
    LOAD = 0
    SAVE = 1

    def __init__(self, holder_frame, type=LOAD, title='File:'):
        self._len_str = 43  # Length of displayed string in widget
        self._pad = 2

        self.title = title
        self.initdir = 'C:\\Users\\tw9616\\Documents\\PhD\\EE Placement\\Lidar\\RPLIDAR_A2M6\\VC2017 Test\\sdk\\output\\win32\\Release\\'
        self.filename = None
        self.filetypes = [('All files', '*.*')]


        # Setup file choice and associated button
        self.frame = tk.Frame(holder_frame)
        lab = ttk.Label(self.frame, text=self.title)
        lab.grid(row=0, column=0)
        self.filename_lab = ttk.Label(self.frame, text='No file selected')
        self.filename_lab.grid(row=0, column=1)

        if type == self.LOAD:
            file_butt = ttk.Button(self.frame, text='Choose file', command=self.select_file)
        elif type == self.SAVE:
            file_butt = ttk.Button(self.frame, text='Choose file', command=self.make_file)
        else:
            print('Warning!!! <type> incorrectly defined in FileSelector, reverting to default [LOAD]')
            file_butt = ttk.Button(self.frame, text='Choose file', command=self.select_file)
        file_butt.grid(row=0, column=2)

    def select_file(self):
        """Create navigation box for selection of file and set filename when chosen"""
        self.filename = filedialog.askopenfilename(initialdir=self.initdir,
                                                    filetypes=self.filetypes,
                                                    title='Select data file')
        self.__config_file_lab__()

    def make_file(self):
        """Create navigation box for creation of new file and update filename when chosen"""
        self.filename = filedialog.asksaveasfilename(initialdir=self.initdir,
                                                    filetypes=self.filetypes,
                                                    title='Define save file')
        self.__config_file_lab__()

    def __config_file_lab__(self):
        """Configure filename label"""
        if not self.filename:
            return
        if len(self.filename) > self._len_str:
            self.filename_lab.configure(text='...' + self.filename[-(self._len_str - 3):])
        else:
            self.filename_lab.configure(text=self.filename)


class PlottingGUI:
    """Class to help with plotting of data in GUI
    ->instantiated by being passed the axis_label argument, defining the labelling of the plot"""
    def __init__(self, frame, axis_label):
        self.frame = tk.Frame(frame, relief=tk.RAISED, borderwidth=5)   # tk frame
        self.axis_label = axis_label    # Axis label (e.g. 'Distance [mm]')
        self.cmap = 'nipy_spectral'     # Colourmap
        self.img_size = [1000, 1000]    # Dimensions of image

        self.__setup_plots__()  # Setup plot areas

    def __setup_plots__(self):
        """Performs initial plot setup"""
        dummy = np.zeros(self.img_size)

        self.fig, self.ax = plt.subplots()
        self.img = self.ax.imshow(dummy, cmap=self.cmap)
        self.cbar = self.fig.colorbar(self.img)
        self.cbar.set_label(self.axis_label)

        self.canv = FigureCanvasTkAgg(self.fig, master=self.frame)
        self.__draw_canv__()
        self.canv.get_tk_widget().pack(side=tk.TOP, fill=tk.BOTH, expand=True)

        self.toolbar = NavigationToolbar2TkAgg(self.canv, self.frame)
        self.toolbar.update()
        self.canv._tkcanvas.pack(side=tk.TOP)

    def update_cmap(self, data):
        """Updates axis with with new data"""
        self.img.set_data(data)                                             # Update data
        self.img.set_clim(vmin=np.nanmin(data), vmax=np.nanmax(data))       # Set colour scale limits
        self.__draw_canv__()                                                    # Draw new plot

    def __draw_canv__(self):
        """Draw canvas"""
        self.canv.show()


class DataHandler:
    """Class to handle and hold all of the data for the GUI so that the main GUI class doesn't get too messy"""
    def __init__(self):
        self.data_array = None

    def save_data(self, filename):
        """Instigate saving of data"""
        save_hdf5(self.data_array, filename)


if __name__ == "__main__":
    root = tk.Tk()
    root.geometry('{0}x{1}+0+0'.format(root.winfo_screenwidth(), root.winfo_screenheight()))
    gui = MainGUI(root)
    root.mainloop()
